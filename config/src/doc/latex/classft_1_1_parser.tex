\hypertarget{classft_1_1_parser}{}\section{Parser Class Reference}
\label{classft_1_1_parser}\index{Parser@{Parser}}


{\ttfamily \#include $<$Parser.\+hpp$>$}



Collaboration diagram for Parser\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=239pt]{classft_1_1_parser__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classft_1_1_parser_a6bfb42ee628e026bebda9adb7ae8b895}{Parser} ()
\item 
std\+::pair$<$ bool, \hyperlink{classft_1_1_http_block}{Http\+Block} $>$ \hyperlink{classft_1_1_parser_ace9c91f641d6eb5467ce89798679b248}{parse} (std\+::vector$<$ \hyperlink{classft_1_1_token}{Token} $>$ \&tokens)
\item 
void \hyperlink{classft_1_1_parser_a8226e5286bd1e9354998fe9e6bb63d08}{modify\+Identifier\+Token} (std\+::vector$<$ \hyperlink{classft_1_1_token}{Token} $>$ \&tokens)
\item 
std\+::pair$<$ bool, \hyperlink{classft_1_1_token}{Token} $>$ \hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expect\+Token} (enum \hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921}{Token\+Type} type, const std\+::string \&name=std\+::string())
\item 
std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ \hyperlink{classft_1_1_parser_ad48298d21629daf7c9a31e101bf322ba}{check\+Valid\+Directive} ()
\item 
std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ \hyperlink{classft_1_1_parser_a31501116433b0b1f8d9d58f27658ea98}{check\+Valid\+Parameter\+Number} (std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ \&valid\+Directive)
\item 
std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ \hyperlink{classft_1_1_parser_abcf864a160e3c4e1866edceae06b921b}{expect\+Http\+Context} ()
\item 
std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ \hyperlink{classft_1_1_parser_a72f108d920a35284bf8f740bb8240acd}{expect\+Server\+Context} ()
\item 
std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ \hyperlink{classft_1_1_parser_a002b236022851df6ef2203aab9b24a73}{expect\+Location\+Context} ()
\item 
std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ \hyperlink{classft_1_1_parser_a81d18b750d54e1e3002070531045171b}{expect\+Simple\+Directive} ()
\item 
std\+::pair$<$ bool, std\+::vector$<$ \hyperlink{classft_1_1_directive}{Directive} $>$ $>$ \hyperlink{classft_1_1_parser_aa8d68b83134b46e4b9115d9acd0cbf57}{parse\+Context\+Body} ()
\item 
std\+::pair$<$ bool, \hyperlink{classft_1_1_http_block}{Http\+Block} $>$ \hyperlink{classft_1_1_parser_a17a213759b2cca8e91ca225b2e86739d}{parse\+Http\+Context} (std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ valid\+Directive)
\item 
std\+::pair$<$ bool, \hyperlink{classft_1_1_server_block}{Server\+Block} $>$ \hyperlink{classft_1_1_parser_ae53bb700e0344f7af2519a5af3ae4230}{parse\+Server\+Context} (\hyperlink{classft_1_1_http_block}{Http\+Block} \&http\+Context, std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ valid\+Directive)
\item 
std\+::pair$<$ bool, \hyperlink{classft_1_1_location_block}{Location\+Block} $>$ \hyperlink{classft_1_1_parser_a4eb83702cdd8772017f71dda995c4089}{parse\+Location\+Context} (\hyperlink{classft_1_1_server_block}{Server\+Block} \&server\+Context, std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ valid\+Directive)
\item 
bool \hyperlink{classft_1_1_parser_a9f412d172694519d0d8dd9edacd257c0}{set\+Base\+Directive\+Parameter} (\hyperlink{classft_1_1_base_directives}{Base\+Directives} \&context, std\+::vector$<$ \hyperlink{classft_1_1_directive}{Directive} $>$\+::iterator \&current\+Directive)
\item 
bool \hyperlink{classft_1_1_parser_a5d287909e4c513e20b017ba0699b0cbf}{set\+Http\+Directive\+Parameter} (\hyperlink{classft_1_1_http_block}{Http\+Block} \&context, std\+::vector$<$ \hyperlink{classft_1_1_directive}{Directive} $>$ directive\+List)
\item 
bool \hyperlink{classft_1_1_parser_a18c1b12280ce1a16246a8ba09156116f}{set\+Server\+Directive\+Parameter} (\hyperlink{classft_1_1_server_block}{Server\+Block} \&context, std\+::vector$<$ \hyperlink{classft_1_1_directive}{Directive} $>$ directive\+List)
\item 
bool \hyperlink{classft_1_1_parser_a82bee2278db1afa69bbb6eb6f192743c}{set\+Location\+Directive\+Parameter} (\hyperlink{classft_1_1_location_block}{Location\+Block} \&context, std\+::vector$<$ \hyperlink{classft_1_1_directive}{Directive} $>$ directive\+List)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::vector$<$ \hyperlink{classft_1_1_token}{Token} $>$\+::iterator \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{current\+Token\+\_\+}
\item 
std\+::vector$<$ \hyperlink{classft_1_1_token}{Token} $>$\+::iterator \hyperlink{classft_1_1_parser_a538ba3ab8ee1d0cef5cc3c999f3ab44c}{end\+Token\+\_\+}
\item 
std\+::map$<$ std\+::string, \hyperlink{classft_1_1_directive}{Directive} $>$ \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\+\_\+}
\end{DoxyCompactItemize}


\subsection{Detailed Description}


Definition at line 18 of file Parser.\+hpp.



\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classft_1_1_parser_a6bfb42ee628e026bebda9adb7ae8b895}\label{classft_1_1_parser_a6bfb42ee628e026bebda9adb7ae8b895}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!Parser@{Parser}}
\index{Parser@{Parser}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{Parser()}{Parser()}}
{\footnotesize\ttfamily \hyperlink{classft_1_1_parser}{Parser} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Definition at line 5 of file Parser.\+cpp.


\begin{DoxyCode}
6     \{
7         \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}[\textcolor{stringliteral}{"http"}] = Directive(\hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67e044074f46e6cea22788527da5f02e}{HTTP}, \textcolor{stringliteral}{"http"});
8         \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}[\textcolor{stringliteral}{"server"}] = Directive(\hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67c96b24b23bcb408bae7626730a04b7}{SERVER}, \textcolor{stringliteral}{"server"});
9         \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}[\textcolor{stringliteral}{"location"}] = Directive(\hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da1e9e3944b93fde52c7c92e1e15dcaf4a}{LOCATION}, \textcolor{stringliteral}{"location"});
10         \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}[\textcolor{stringliteral}{"client\_max\_body\_size"}] = Directive(
      \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da026a7fa9f276b046081164564a62a6d6}{CLIENT\_MAX\_BODY\_SIZE}, \textcolor{stringliteral}{"client\_max\_body\_size"});
11         \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}[\textcolor{stringliteral}{"keepalive\_timeout"}] = Directive(
      \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75daaefe179bd74ff161beb62eb565186d89}{KEEPALIVE\_TIMEOUT}, \textcolor{stringliteral}{"keepalive\_timeout"});
12         \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}[\textcolor{stringliteral}{"index"}] = Directive(\hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da5f0c05bad71a7b0dd266aae7ce4b3579}{INDEX}, \textcolor{stringliteral}{"index"});
13         \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}[\textcolor{stringliteral}{"autoindex"}] = Directive(\hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da8ce880864e00bec4865ba027e32a466c}{AUTOINDEX}, \textcolor{stringliteral}{"autoindex"});
14         \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}[\textcolor{stringliteral}{"root"}] = Directive(\hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75dad41208b99e347d1726824779b11ea11b}{ROOT}, \textcolor{stringliteral}{"root"});
15         \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}[\textcolor{stringliteral}{"error\_page"}] = Directive(\hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da69c9592b502329f43c77ad043a13e6d9}{ERROR\_PAGE}, \textcolor{stringliteral}{"error\_page"});
16         \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}[\textcolor{stringliteral}{"listen"}] = Directive(\hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da331ec9878c0ed22e62de969d4b96b5bb}{LISTEN}, \textcolor{stringliteral}{"listen"});
17         \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}[\textcolor{stringliteral}{"server\_name"}] = Directive(\hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da8e7adb687472b53e3ed632cbcb949d88}{SERVER\_NAME}, \textcolor{stringliteral}{"server\_name"});
18         \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}[\textcolor{stringliteral}{"return"}] = Directive(\hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da520e09ffec033636dba711f3441cc600}{RETURN}, \textcolor{stringliteral}{"return"});
19         \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}[\textcolor{stringliteral}{"limit\_except"}] = Directive(\hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da25b0e84438d71cc28e97f17a01cfde7a}{LIMIT\_EXCEPT}, \textcolor{stringliteral}{"limit\_except"});
20     \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classft_1_1_parser_ad48298d21629daf7c9a31e101bf322ba}\label{classft_1_1_parser_ad48298d21629daf7c9a31e101bf322ba}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!check\+Valid\+Directive@{check\+Valid\+Directive}}
\index{check\+Valid\+Directive@{check\+Valid\+Directive}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{check\+Valid\+Directive()}{checkValidDirective()}}
{\footnotesize\ttfamily std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ check\+Valid\+Directive (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Definition at line 147 of file Parser.\+cpp.


\begin{DoxyCode}
148     \{
149         \textcolor{comment}{//std::pair<bool, Token> possibleDirectiveToken = expectDirective();}
150         std::pair<bool, Token> possibleDirectiveToken = \hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(
      \hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921ae3852cb010d5e422026faf83b3c16f0e}{DIRECTIVE});
151         std::map<std::string, Directive>::iterator foundDirective;
152 
153         \textcolor{keywordflow}{if} (!possibleDirectiveToken.first)
154             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}.begin()->second)); 
155         foundDirective = \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}.find(possibleDirectiveToken.second.text);
156         \textcolor{keywordflow}{if} (foundDirective == \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}.end())
157         \{
158             --\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_};
159             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, \hyperlink{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}{directives\_}.begin()->second)); 
160         \}
161         \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{true}, foundDirective->second)); 
162     \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=293pt]{classft_1_1_parser_ad48298d21629daf7c9a31e101bf322ba_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_ad48298d21629daf7c9a31e101bf322ba_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_a31501116433b0b1f8d9d58f27658ea98}\label{classft_1_1_parser_a31501116433b0b1f8d9d58f27658ea98}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!check\+Valid\+Parameter\+Number@{check\+Valid\+Parameter\+Number}}
\index{check\+Valid\+Parameter\+Number@{check\+Valid\+Parameter\+Number}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{check\+Valid\+Parameter\+Number()}{checkValidParameterNumber()}}
{\footnotesize\ttfamily std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ check\+Valid\+Parameter\+Number (\begin{DoxyParamCaption}\item[{std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ \&}]{valid\+Directive }\end{DoxyParamCaption})}



Definition at line 662 of file Parser.\+cpp.


\begin{DoxyCode}
663     \{
664         std::vector<Token>::iterator startToken = \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_};
665         \textcolor{comment}{//std::pair<bool, Token> possibleParameter = expectParameter();}
666         std::pair<bool, Token> possibleParameter = \hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(
      \hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a194cde856bd2d79eac8adb9741c55940}{PARAMETER});
667 
668         std::cout << \textcolor{stringliteral}{"in checkValidParameterNumber ("} << validDirective.second.name << \textcolor{stringliteral}{", "} << 
      possibleParameter.second.text << \textcolor{stringliteral}{")\(\backslash\)n"};
669         \textcolor{keywordflow}{if} (possibleParameter.first == \textcolor{keyword}{true})
670         \{
671             \textcolor{comment}{//std::cout << "in checkValidParameterNumber (" << validDirective.second.name << ", " <<
       possibleParameter.second.text << ")\(\backslash\)n";}
672             \textcolor{keywordflow}{if} ((validDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da8e7adb687472b53e3ed632cbcb949d88}{SERVER\_NAME}) ||
673                     (validDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da25b0e84438d71cc28e97f17a01cfde7a}{LIMIT\_EXCEPT}) ||
674                     (validDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da5f0c05bad71a7b0dd266aae7ce4b3579}{INDEX}) ||
675                     (validDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da520e09ffec033636dba711f3441cc600}{RETURN}))
676             \{
677                 \textcolor{keywordflow}{while} (possibleParameter.first == \textcolor{keyword}{true})
678                 \{
679                     validDirective.second.parameters.push\_back(possibleParameter.second.text);
680                     \textcolor{comment}{//possibleParameter = expectParameter();}
681                     possibleParameter = \hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(\hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a194cde856bd2d79eac8adb9741c55940}{PARAMETER});
682                 \}
683             \}
684             \textcolor{keywordflow}{else}
685                 \textcolor{comment}{//if (possibleParameter.first == true)}
686                 validDirective.second.parameters.push\_back(possibleParameter.second.text);
687         \}
688         \textcolor{keywordflow}{else}
689         \{
690             std::cout << \textcolor{stringliteral}{"Error: Simple directive should at least one parameter\(\backslash\)n"};
691             \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = startToken;
692             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, validDirective.second));
693         \}
694         \textcolor{comment}{//possibleParameter = expectParameter();}
695         possibleParameter = \hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(\hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a194cde856bd2d79eac8adb9741c55940}{PARAMETER});
696         \textcolor{keywordflow}{if} (possibleParameter.first == \textcolor{keyword}{true})
697         \{
698             \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = startToken;
699             std::cout << \textcolor{stringliteral}{"Error: There can't be more parameters with directive "} << validDirective.second.
      name << \textcolor{stringliteral}{", "};
700             std::cout << \textcolor{stringliteral}{"additional parameter is "} << possibleParameter.second.text<< \textcolor{stringliteral}{"\(\backslash\)n"};
701             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, validDirective.second));
702         \}
703         \textcolor{comment}{//std::pair<bool, Token> possibleOperator = expectOperator(";");}
704         std::pair<bool, Token> possibleOperator = \hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(
      \hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a6411d9d6073252e4d316493506bbb979}{OPERATOR}, \textcolor{stringliteral}{";"});
705         \textcolor{keywordflow}{if} (possibleOperator.first == \textcolor{keyword}{false})
706         \{
707             \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = startToken;
708             std::cout << \textcolor{stringliteral}{"Error: Simple directive should be terminated by ';' \(\backslash\)n"};
709             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, validDirective.second));
710         \}
711         \textcolor{comment}{//return (std::make\_pair(true, validDirective.second));}
712         std::cout << \textcolor{stringliteral}{"in checkValidParameterNumber :"} << validDirective.second.name << \textcolor{stringliteral}{"\(\backslash\)n"};
713         std::vector<std::string>::iterator  currtToken = validDirective.second.parameters.begin();
714         std::vector<std::string>::iterator  endToken = validDirective.second.parameters.end();
715         \textcolor{keywordflow}{for} (; currtToken != endToken; ++currtToken)
716             std::cout << \textcolor{stringliteral}{"parameter: "} << *currtToken << \textcolor{stringliteral}{"\(\backslash\)n"};
717         \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{true}, validDirective.second));
718     \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=333pt]{classft_1_1_parser_a31501116433b0b1f8d9d58f27658ea98_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a31501116433b0b1f8d9d58f27658ea98_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_abcf864a160e3c4e1866edceae06b921b}\label{classft_1_1_parser_abcf864a160e3c4e1866edceae06b921b}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!expect\+Http\+Context@{expect\+Http\+Context}}
\index{expect\+Http\+Context@{expect\+Http\+Context}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{expect\+Http\+Context()}{expectHttpContext()}}
{\footnotesize\ttfamily std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ expect\+Http\+Context (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Definition at line 2 of file dummy.\+cpp.


\begin{DoxyCode}
3     \{
4         std::vector<Token>::iterator parseStart = \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_};
5         std::pair<bool, Directive> possibleValidDirective = \hyperlink{classft_1_1_parser_ad48298d21629daf7c9a31e101bf322ba}{checkValidDirective}();
6         std::pair<bool, std::vector<Directive> > directives;
7         HttpBlock   httpContext;
8 
9         \textcolor{keywordflow}{if} (possibleValidDirective.first == \textcolor{keyword}{true}) \textcolor{comment}{// When we have a block directive name}
10         \{
11             std::pair<bool, Token> possibleOperator = expectOperator(\textcolor{stringliteral}{"\{"});
12             \textcolor{keywordflow}{if} (possibleOperator.first == \textcolor{keyword}{true}) \textcolor{comment}{// When we have a block directive}
13             \{
14                 \textcolor{comment}{//std::cout << "We have a block directive: " << possibleValidDirective.second.name << "\(\backslash\)n";}
15                 \textcolor{keywordflow}{if} (possibleValidDirective.second.directive != \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67e044074f46e6cea22788527da5f02e}{HTTP})
16                 \{
17                     std::cout << \textcolor{stringliteral}{"Error: It should start with http context but the directive is "} << 
      possibleValidDirective.second.name << \textcolor{stringliteral}{"\(\backslash\)n"};
18                     \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
19                     \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, httpContext));
20                 \}
21                 \textcolor{keywordflow}{return}(\hyperlink{classft_1_1_parser_a17a213759b2cca8e91ca225b2e86739d}{parseHttpContext}(possibleValidDirective));
22 \textcolor{comment}{/*}
23 \textcolor{comment}{                while (expectOperator("\}").first == false)}
24 \textcolor{comment}{                \{}
25 \textcolor{comment}{                    possibleValidDirective = expectServerContext();}
26 \textcolor{comment}{                    if (possibleValidDirective.first == false)}
27 \textcolor{comment}{                    \{}
28 \textcolor{comment}{                        std::cout << "there is no server block, start to parse context body, ";}
29 \textcolor{comment}{                        std::cout << "currentToken is :" << currentToken\_->text << "\(\backslash\)n";}
30 \textcolor{comment}{                        directives = parseContextBody();}
31 \textcolor{comment}{                        if (!directives.first)}
32 \textcolor{comment}{                        \{}
33 \textcolor{comment}{                            currentToken\_ = parseStart;}
34 \textcolor{comment}{                            return (std::make\_pair(false, httpContext));}
35 \textcolor{comment}{                        \}}
36 \textcolor{comment}{                        httpContext.directiveList.insert(httpContext.directiveList.end(),
       directives.second.begin(), directives.second.end());}
37 \textcolor{comment}{                        //directives.second.insert(directives.second.end(), tempDirectives.second.begin(),
       tempDirectives.second.end());}
38 \textcolor{comment}{                    \}}
39 \textcolor{comment}{                    else}
40 \textcolor{comment}{                    \{}
41 \textcolor{comment}{                        std::pair<bool, ServerBlock>    possibleServerContext =
       parseServerContext(possibleValidDirective);}
42 \textcolor{comment}{                        }
43 \textcolor{comment}{                        //std::cout << "there is no server block, start to parse context body, ";}
44 \textcolor{comment}{                        //std::cout << "currentToken is :" << currentToken\_->text << "\(\backslash\)n";}
45 \textcolor{comment}{                        //directives = parseContextBody();}
46 \textcolor{comment}{                        if (possibleServerContext.first == false)}
47 \textcolor{comment}{                        //if (!directives.first)}
48 \textcolor{comment}{                        \{}
49 \textcolor{comment}{                            currentToken\_ = parseStart;}
50 \textcolor{comment}{                            return (std::make\_pair(false, httpContext));}
51 \textcolor{comment}{                        \}}
52 \textcolor{comment}{                        //serverContext.directiveList.insert(serverContext.directiveList.end(),
       directives.second.begin(), directives.second.end());}
53 \textcolor{comment}{                        httpContext.serverList.push\_back(possibleServerContext.second);}
54 \textcolor{comment}{                        std::cout << "One server context has been successfuly enclosed with a closing curly
       braket" << "\(\backslash\)n";}
55 \textcolor{comment}{                        std::vector<Directive>::iterator    currtToken =
       possibleServerContext.second.directiveList.begin();}
56 \textcolor{comment}{                        std::vector<Directive>::iterator    endToken =
       possibleServerContext.second.directiveList.end();}
57 \textcolor{comment}{                        for (; currtToken != endToken; ++currtToken)}
58 \textcolor{comment}{                            std::cout << "serverContext Directive: " << (*currtToken).name << "\(\backslash\)n";}
59 \textcolor{comment}{                    \}}
60 \textcolor{comment}{}
61 \textcolor{comment}{                \}}
62 \textcolor{comment}{                std::cout << "Http context has been successfuly enclosed with a closing curly braket" <<
       "\(\backslash\)n";}
63 \textcolor{comment}{                //std::cout << "in checkValidParameterNumber :" << validDirective.second.name << "\(\backslash\)n";}
64 \textcolor{comment}{                //std::vector<Directive>::iterator  currtToken = directives.second.begin();}
65 \textcolor{comment}{                //std::vector<Directive>::iterator  endToken = directives.second.end();}
66 \textcolor{comment}{                std::vector<Directive>::iterator    currtToken = httpContext.directiveList.begin();}
67 \textcolor{comment}{                std::vector<Directive>::iterator    endToken = httpContext.directiveList.end();}
68 \textcolor{comment}{                for (; currtToken != endToken; ++currtToken)}
69 \textcolor{comment}{                    std::cout << "httpContext Directive: " << (*currtToken).name << "\(\backslash\)n";}
70 \textcolor{comment}{                //if (returnHttpContext.first == false)}
71 \textcolor{comment}{                //return (returnHttpContext);}
72 \textcolor{comment}{*/}
73                 \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{true}, httpContext));
74             \}
75             \textcolor{keywordflow}{else}
76                 \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
77                 \textcolor{comment}{//--currentToken\_;}
78         \}
79         \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, httpContext));
80     \}
\end{DoxyCode}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_abcf864a160e3c4e1866edceae06b921b_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_a002b236022851df6ef2203aab9b24a73}\label{classft_1_1_parser_a002b236022851df6ef2203aab9b24a73}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!expect\+Location\+Context@{expect\+Location\+Context}}
\index{expect\+Location\+Context@{expect\+Location\+Context}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{expect\+Location\+Context()}{expectLocationContext()}}
{\footnotesize\ttfamily std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ expect\+Location\+Context (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Definition at line 514 of file Parser.\+cpp.


\begin{DoxyCode}
515     \{
516         std::vector<Token>::iterator parseStart = \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_};
517         std::pair<bool, Directive> possibleValidDirective = \hyperlink{classft_1_1_parser_ad48298d21629daf7c9a31e101bf322ba}{checkValidDirective}();
518 
519         \textcolor{keywordflow}{if} (possibleValidDirective.first == \textcolor{keyword}{false}) 
520         \{
521             \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
522             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, possibleValidDirective.second));
523         \}
524         \textcolor{keywordflow}{if} ((possibleValidDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67c96b24b23bcb408bae7626730a04b7}{SERVER}) || 
525             (possibleValidDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67e044074f46e6cea22788527da5f02e}{HTTP}))
526         \{
527             \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
528             std::cout << \textcolor{stringliteral}{"Error: There can't be any "} << \hyperlink{namespaceft_a2896a632198d516af93e4aea2d125f59}{sDirectiveKindStrings}[
      possibleValidDirective.second.directive] 
529                 << \textcolor{stringliteral}{" block inside a server block"} << \textcolor{stringliteral}{", "};
530             std::cout << \textcolor{stringliteral}{"currentToken is :"} << \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_}->text << \textcolor{stringliteral}{"\(\backslash\)n"};
531             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, possibleValidDirective.second));
532         \}
533         \textcolor{keywordflow}{if} (possibleValidDirective.second.directive != \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da1e9e3944b93fde52c7c92e1e15dcaf4a}{LOCATION})
534         \{
535             \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
536             std::cout << \textcolor{stringliteral}{"It is not a location block but, "} << possibleValidDirective.second.name << \textcolor{stringliteral}{", "};
537             std::cout << \textcolor{stringliteral}{"currentToken is :"} << \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_}->text << \textcolor{stringliteral}{"\(\backslash\)n"};
538             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, possibleValidDirective.second));
539         \}
540         \textcolor{comment}{//std::pair<bool, Token> possibleParameter = expectParameter();}
541         std::pair<bool, Token> possibleParameter = \hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(
      \hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a194cde856bd2d79eac8adb9741c55940}{PARAMETER});
542         \textcolor{keywordflow}{if} (possibleParameter.first == \textcolor{keyword}{false})
543         \{
544             \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
545             std::cout << \textcolor{stringliteral}{"Error: no parameter: Location directive should have one URI path\(\backslash\)n"};
546             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, possibleValidDirective.second));
547         \}
548         possibleValidDirective.second.parameters.push\_back(possibleParameter.second.text);
549         \textcolor{comment}{//if (expectOperator("\{").first == false)}
550         \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(\hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a6411d9d6073252e4d316493506bbb979}{OPERATOR}, \textcolor{stringliteral}{"\{"}).first == \textcolor{keyword}{false})
551         \{
552             \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
553             std::cout << \textcolor{stringliteral}{"Error: Mutiple parameters, location directive should only have one URI path\(\backslash\)n"};
554             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, possibleValidDirective.second));
555         \}
556         \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{true}, possibleValidDirective.second));
557     \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a002b236022851df6ef2203aab9b24a73_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a002b236022851df6ef2203aab9b24a73_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_a72f108d920a35284bf8f740bb8240acd}\label{classft_1_1_parser_a72f108d920a35284bf8f740bb8240acd}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!expect\+Server\+Context@{expect\+Server\+Context}}
\index{expect\+Server\+Context@{expect\+Server\+Context}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{expect\+Server\+Context()}{expectServerContext()}}
{\footnotesize\ttfamily std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ expect\+Server\+Context (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Definition at line 420 of file Parser.\+cpp.


\begin{DoxyCode}
421     \{
422         std::vector<Token>::iterator parseStart = \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_};
423         std::pair<bool, Directive> possibleValidDirective = \hyperlink{classft_1_1_parser_ad48298d21629daf7c9a31e101bf322ba}{checkValidDirective}();
424 
425         \textcolor{keywordflow}{if} (possibleValidDirective.first == \textcolor{keyword}{false}) 
426         \{
427             \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
428             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, possibleValidDirective.second));
429         \}
430         \textcolor{keywordflow}{if} (possibleValidDirective.second.directive != \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67c96b24b23bcb408bae7626730a04b7}{SERVER})
431         \{
432             \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
433             std::cout << \textcolor{stringliteral}{"It is not a server block but, "} << possibleValidDirective.second.name << \textcolor{stringliteral}{", "};
434             std::cout << \textcolor{stringliteral}{"currentToken is :"} << \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_}->text << \textcolor{stringliteral}{"\(\backslash\)n"};
435             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, possibleValidDirective.second));
436         \}
437         \textcolor{comment}{//if (expectOperator("\{").first == false)}
438         \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(\hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a6411d9d6073252e4d316493506bbb979}{OPERATOR}, \textcolor{stringliteral}{"\{"}).first == \textcolor{keyword}{false})
439         \{
440             \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
441             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, possibleValidDirective.second));
442         \}
443         \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{true}, possibleValidDirective.second));
444     \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a72f108d920a35284bf8f740bb8240acd_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a72f108d920a35284bf8f740bb8240acd_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_a81d18b750d54e1e3002070531045171b}\label{classft_1_1_parser_a81d18b750d54e1e3002070531045171b}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!expect\+Simple\+Directive@{expect\+Simple\+Directive}}
\index{expect\+Simple\+Directive@{expect\+Simple\+Directive}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{expect\+Simple\+Directive()}{expectSimpleDirective()}}
{\footnotesize\ttfamily std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$ expect\+Simple\+Directive (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Definition at line 635 of file Parser.\+cpp.


\begin{DoxyCode}
636     \{
637         (void)\hyperlink{namespaceft_a1b9b00bc284da71346729142b8560e03}{ft::sTokenTypeStrings}[\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_}->type]; \textcolor{comment}{// for debuging}
638         std::vector<Token>::iterator startToken = \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_};
639         std::pair<bool, Directive> possibleValidDirective = \hyperlink{classft_1_1_parser_ad48298d21629daf7c9a31e101bf322ba}{checkValidDirective}();
640         \textcolor{keywordflow}{if} (possibleValidDirective.first == \textcolor{keyword}{true})
641         \{
642             \textcolor{keywordflow}{if} ((possibleValidDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67e044074f46e6cea22788527da5f02e}{HTTP}) ||
643                     (possibleValidDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67c96b24b23bcb408bae7626730a04b7}{SERVER}) ||
644                     (possibleValidDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da1e9e3944b93fde52c7c92e1e15dcaf4a}{LOCATION})) \textcolor{comment}{// check block directive}
645             \{
646                 \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = startToken;
647                 std::cout << \textcolor{stringliteral}{"parseSimpleDirective is context"} << \textcolor{stringliteral}{"\(\backslash\)n"};
648                 \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, possibleValidDirective.second));
649             \}
650         \}
651         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (possibleValidDirective.first == \textcolor{keyword}{false})
652         \{
653             \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(\hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a6411d9d6073252e4d316493506bbb979}{OPERATOR}, \textcolor{stringliteral}{"\}"}).first == \textcolor{keyword}{true})
654                 \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{true}, possibleValidDirective.second));
655             std::cout << \textcolor{stringliteral}{"parseSimpleDirective first is false"} << \textcolor{stringliteral}{"\(\backslash\)n"};
656             \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = startToken;
657             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, possibleValidDirective.second));
658         \}
659         \textcolor{keywordflow}{return} (\hyperlink{classft_1_1_parser_a31501116433b0b1f8d9d58f27658ea98}{checkValidParameterNumber}(possibleValidDirective));
660     \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a81d18b750d54e1e3002070531045171b_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a81d18b750d54e1e3002070531045171b_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}\label{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!expect\+Token@{expect\+Token}}
\index{expect\+Token@{expect\+Token}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{expect\+Token()}{expectToken()}}
{\footnotesize\ttfamily std\+::pair$<$ bool, \hyperlink{classft_1_1_token}{Token} $>$ expect\+Token (\begin{DoxyParamCaption}\item[{enum \hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921}{Token\+Type}}]{type,  }\item[{const std\+::string \&}]{name = {\ttfamily std\+:\+:string()} }\end{DoxyParamCaption})}



Definition at line 131 of file Parser.\+cpp.


\begin{DoxyCode}
132     \{
133         Token returnToken;
134 
135         \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} == \hyperlink{classft_1_1_parser_a538ba3ab8ee1d0cef5cc3c999f3ab44c}{endToken\_})
136             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, returnToken));
137         \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_}->type != type)
138             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, returnToken));
139         \textcolor{keywordflow}{if} (!name.empty() && \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_}->text != name)
140             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, returnToken));
141 
142         returnToken = *\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_};
143         ++\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_};
144         \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{true}, returnToken));
145     \}
\end{DoxyCode}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_a8226e5286bd1e9354998fe9e6bb63d08}\label{classft_1_1_parser_a8226e5286bd1e9354998fe9e6bb63d08}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!modify\+Identifier\+Token@{modify\+Identifier\+Token}}
\index{modify\+Identifier\+Token@{modify\+Identifier\+Token}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{modify\+Identifier\+Token()}{modifyIdentifierToken()}}
{\footnotesize\ttfamily void modify\+Identifier\+Token (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \hyperlink{classft_1_1_token}{Token} $>$ \&}]{tokens }\end{DoxyParamCaption})}



Definition at line 55 of file Parser.\+cpp.


\begin{DoxyCode}
56     \{
57         \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = tokens.begin();
58         \hyperlink{classft_1_1_parser_a538ba3ab8ee1d0cef5cc3c999f3ab44c}{endToken\_} = tokens.end();
59 
60         \textcolor{keywordflow}{for} (;\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} != \hyperlink{classft_1_1_parser_a538ba3ab8ee1d0cef5cc3c999f3ab44c}{endToken\_}; ++\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_})
61         \{
62             \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_}->type == \hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a84f8ae2490f9e4bd2321fd21f4b0e807}{IDENTIFIER})
63             \{
64                 \textcolor{keywordtype}{int} i = 0, foundDirectiveKind = -1;
65                 \textcolor{keywordflow}{while} (i < \hyperlink{_directive_8hpp_a0ad99aeee867cb461c93463d5772ac86}{LAST\_DIRECTIVE\_KIND} + 1)
66                 \{
67                     foundDirectiveKind = \hyperlink{namespaceft_a2896a632198d516af93e4aea2d125f59}{sDirectiveKindStrings}[i].compare(
      \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_}->text);
68                     \textcolor{keywordflow}{if} (foundDirectiveKind == 0)
69                     \{
70                         std::cout << \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_}->text << std::endl;
71                         \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_}->type = \hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921ae3852cb010d5e422026faf83b3c16f0e}{DIRECTIVE};
72                         break ;
73                     \}
74                     i++;
75                 \}
76                 \textcolor{keywordflow}{if} (i == \hyperlink{_directive_8hpp_a0ad99aeee867cb461c93463d5772ac86}{LAST\_DIRECTIVE\_KIND} + 1)
77                     \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_}->type = \hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a194cde856bd2d79eac8adb9741c55940}{PARAMETER};
78             \}
79 
80         \}
81     \}
\end{DoxyCode}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=341pt]{classft_1_1_parser_a8226e5286bd1e9354998fe9e6bb63d08_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_ace9c91f641d6eb5467ce89798679b248}\label{classft_1_1_parser_ace9c91f641d6eb5467ce89798679b248}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!parse@{parse}}
\index{parse@{parse}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{parse()}{parse()}}
{\footnotesize\ttfamily std\+::pair$<$ bool, \hyperlink{classft_1_1_http_block}{Http\+Block} $>$ parse (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \hyperlink{classft_1_1_token}{Token} $>$ \&}]{tokens }\end{DoxyParamCaption})}



Definition at line 22 of file Parser.\+cpp.


\begin{DoxyCode}
23     \{
24         \hyperlink{classft_1_1_parser_a8226e5286bd1e9354998fe9e6bb63d08}{modifyIdentifierToken}(tokens);
25         \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = tokens.begin();
26         \hyperlink{classft_1_1_parser_a538ba3ab8ee1d0cef5cc3c999f3ab44c}{endToken\_} = tokens.end();
27         std::pair<bool, HttpBlock> possibleHttpContext;
28         std::pair<bool, Directive> possibleValidDirective;
29 
30 \textcolor{comment}{/*}
31 \textcolor{comment}{        possibleValidDirective = expectHttpContext2();}
32 \textcolor{comment}{        if (possibleValidDirective.first == false)}
33 \textcolor{comment}{            return (possibleHttpContext);}
34 \textcolor{comment}{        return (parseHttpContext(possibleValidDirective));}
35 \textcolor{comment}{*/}
36         \textcolor{keywordflow}{while} (\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} != \hyperlink{classft_1_1_parser_a538ba3ab8ee1d0cef5cc3c999f3ab44c}{endToken\_})
37         \{
38             possibleValidDirective = \hyperlink{classft_1_1_parser_abcf864a160e3c4e1866edceae06b921b}{expectHttpContext}();
39             \textcolor{keywordflow}{if} (possibleValidDirective.first == \textcolor{keyword}{false})
40             \{
41                 \textcolor{comment}{//std::cerr << "Unknown directive " << currentToken\_->text << "$" << std::endl;}
42                 \textcolor{comment}{//break ;}
43                 ++\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_};
44             \}
45             \textcolor{keywordflow}{else}
46             \{
47                 possibleHttpContext = \hyperlink{classft_1_1_parser_a17a213759b2cca8e91ca225b2e86739d}{parseHttpContext}(possibleValidDirective);
48                 \textcolor{keywordflow}{if} (possibleHttpContext.first == \textcolor{keyword}{false})
49                     \textcolor{keywordflow}{return} (possibleHttpContext);
50             \}
51         \}
52         \textcolor{keywordflow}{return} (possibleHttpContext);
53     \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_ace9c91f641d6eb5467ce89798679b248_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=195pt]{classft_1_1_parser_ace9c91f641d6eb5467ce89798679b248_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_aa8d68b83134b46e4b9115d9acd0cbf57}\label{classft_1_1_parser_aa8d68b83134b46e4b9115d9acd0cbf57}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!parse\+Context\+Body@{parse\+Context\+Body}}
\index{parse\+Context\+Body@{parse\+Context\+Body}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{parse\+Context\+Body()}{parseContextBody()}}
{\footnotesize\ttfamily std\+::pair$<$ bool, std\+::vector$<$ \hyperlink{classft_1_1_directive}{Directive} $>$ $>$ parse\+Context\+Body (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Definition at line 607 of file Parser.\+cpp.


\begin{DoxyCode}
608     \{
609         std::vector<Directive>  directives;
610         std::cout << \textcolor{stringliteral}{"start parseContextBody."} << \textcolor{stringliteral}{"\(\backslash\)n"};
611         std::pair<bool, Directive> simpleDirective = \hyperlink{classft_1_1_parser_a81d18b750d54e1e3002070531045171b}{expectSimpleDirective}();
612 
613         \textcolor{keywordflow}{while} (simpleDirective.first == \textcolor{keyword}{true})
614         \{
615             \textcolor{comment}{//std::cout << "current simpleDirective.second.name: " << simpleDirective.second.name << "\(\backslash\)n";}
616             directives.push\_back(simpleDirective.second);
617             simpleDirective = \hyperlink{classft_1_1_parser_a81d18b750d54e1e3002070531045171b}{expectSimpleDirective}();
618         \}
619         \textcolor{comment}{//if (!expectOperator("\}").first)}
620         \textcolor{comment}{//  return std::runtime\_error("Unbalanced \}");}
621         \textcolor{comment}{//std::cout << "last simpleDirective.second.name: " << simpleDirective.second.name << "\(\backslash\)n";}
622         \textcolor{keywordflow}{if} (simpleDirective.first == \textcolor{keyword}{false})
623         \{
624             \textcolor{keywordflow}{if} ((simpleDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67e044074f46e6cea22788527da5f02e}{HTTP}) ||
625                     (simpleDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67c96b24b23bcb408bae7626730a04b7}{SERVER}) ||
626                     (simpleDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da1e9e3944b93fde52c7c92e1e15dcaf4a}{LOCATION})) \textcolor{comment}{// check block directive}
627             \{
628                 std::cout << \textcolor{stringliteral}{"there is a block, return to expectContext func.\(\backslash\)n"};
629                 \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{true}, directives));
630             \}
631         \}
632         \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, directives));
633     \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_aa8d68b83134b46e4b9115d9acd0cbf57_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_aa8d68b83134b46e4b9115d9acd0cbf57_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_a17a213759b2cca8e91ca225b2e86739d}\label{classft_1_1_parser_a17a213759b2cca8e91ca225b2e86739d}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!parse\+Http\+Context@{parse\+Http\+Context}}
\index{parse\+Http\+Context@{parse\+Http\+Context}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{parse\+Http\+Context()}{parseHttpContext()}}
{\footnotesize\ttfamily std\+::pair$<$ bool, \hyperlink{classft_1_1_http_block}{Http\+Block} $>$ parse\+Http\+Context (\begin{DoxyParamCaption}\item[{std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$}]{valid\+Directive }\end{DoxyParamCaption})}



Definition at line 350 of file Parser.\+cpp.


\begin{DoxyCode}
351     \{
352         std::vector<Token>::iterator parseStart = \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_};
353         std::pair<bool, std::vector<Directive> > directives;
354         HttpBlock   httpContext;
355 
356         \textcolor{comment}{//while (currentToken\_ != endToken\_ && expectOperator("\}").first == false)}
357         \textcolor{keywordflow}{while} (\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} != \hyperlink{classft_1_1_parser_a538ba3ab8ee1d0cef5cc3c999f3ab44c}{endToken\_} && \hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(
      \hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a6411d9d6073252e4d316493506bbb979}{OPERATOR}, \textcolor{stringliteral}{"\}"}).first == \textcolor{keyword}{false})
358         \{
359             validDirective = \hyperlink{classft_1_1_parser_a72f108d920a35284bf8f740bb8240acd}{expectServerContext}();
360             \textcolor{keywordflow}{if} (validDirective.first == \textcolor{keyword}{false})
361             \{
362                 std::cout << \textcolor{stringliteral}{"there is no server block, start to parse context body, "};
363                 std::cout << \textcolor{stringliteral}{"currentToken is :"} << \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_}->text << \textcolor{stringliteral}{"\(\backslash\)n"};
364                 directives = \hyperlink{classft_1_1_parser_aa8d68b83134b46e4b9115d9acd0cbf57}{parseContextBody}();
365                 \textcolor{keywordflow}{if} (!directives.first)
366                 \{
367                     std::cout << \textcolor{stringliteral}{"directives first false in parse http context: "} << \textcolor{stringliteral}{"\(\backslash\)n"};
368                     \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
369                     \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, httpContext));
370                 \}
371                 \textcolor{comment}{//httpContext.directiveList.insert(httpContext.directiveList.end(),
       directives.second.begin(), directives.second.end());}
372                 \textcolor{comment}{//std::cout << "currnt token in parse http context: " << currentToken\_->text << "\(\backslash\)n";}
373                 \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a5d287909e4c513e20b017ba0699b0cbf}{setHttpDirectiveParameter}(httpContext, directives.second) == \textcolor{keyword}{
      false})
374                     \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, httpContext));
375                 
376             \}
377             \textcolor{keywordflow}{else}
378             \{
379                 std::pair<bool, ServerBlock>    possibleServerContext = 
      \hyperlink{classft_1_1_parser_ae53bb700e0344f7af2519a5af3ae4230}{parseServerContext}(httpContext, validDirective);
380 
381                 \textcolor{comment}{//std::cout << "there is no server block, start to parse context body, ";}
382                 \textcolor{comment}{//std::cout << "currentToken is :" << currentToken\_->text << "\(\backslash\)n";}
383                 \textcolor{keywordflow}{if} (possibleServerContext.first == \textcolor{keyword}{false})
384                 \{
385                     \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
386                     \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, httpContext));
387                 \}
388                 httpContext.serverList.push\_back(possibleServerContext.second);
389                 std::cout << \textcolor{stringliteral}{"One server context has been successfuly enclosed with a closing curly braket"}
       << \textcolor{stringliteral}{"\(\backslash\)n"};
390                 \textcolor{comment}{//std::vector<Directive>::iterator  currtToken =
       possibleServerContext.second.directiveList.begin();}
391                 \textcolor{comment}{//std::vector<Directive>::iterator  endToken =
       possibleServerContext.second.directiveList.end();}
392                 \textcolor{comment}{//for (; currtToken != endToken; ++currtToken)}
393                 \textcolor{comment}{//  std::cout << "serverContext Directive: " << (*currtToken).name << "\(\backslash\)n";}
394             \}
395 
396         \}
397         \textcolor{comment}{//if (currentToken\_ == endToken\_ - 1 && expectToken(OPERATOR, "\}").first == false)}
398         \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(\hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a6411d9d6073252e4d316493506bbb979}{OPERATOR}, \textcolor{stringliteral}{"\}"}).first == \textcolor{keyword}{false})
399         \{
400             \textcolor{comment}{//std::cout << "currnt token af while in parse http context: " << currentToken\_->text << "\(\backslash\)n";}
401             \textcolor{comment}{//std::cout << "end token af while in parse http context: " << endToken\_->text << "\(\backslash\)n";}
402             std::cout << \textcolor{stringliteral}{"Error: Http context has not successfuly been enclosed with a closing curly
       braket.\(\backslash\)n"};
403             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, httpContext));
404         \}
405 \textcolor{comment}{/*}
406 \textcolor{comment}{        std::cout << "Http context has successfuly been enclosed with a closing curly braket.\(\backslash\)n";}
407 \textcolor{comment}{        //std::cout << "in checkValidParameterNumber :" << validDirective.second.name << "\(\backslash\)n";}
408 \textcolor{comment}{        //std::vector<Directive>::iterator  currtToken = directives.second.begin();}
409 \textcolor{comment}{        //std::vector<Directive>::iterator  endToken = directives.second.end();}
410 \textcolor{comment}{        std::vector<Directive>::iterator    currtToken = httpContext.directiveList.begin();}
411 \textcolor{comment}{        std::vector<Directive>::iterator    endToken = httpContext.directiveList.end();}
412 \textcolor{comment}{        for (; currtToken != endToken; ++currtToken)}
413 \textcolor{comment}{            std::cout << "httpContext Directive: " << (*currtToken).name << "\(\backslash\)n";}
414 \textcolor{comment}{*/}          
415         \textcolor{comment}{//if (returnHttpContext.first == false)}
416         \textcolor{comment}{//return (returnHttpContext);}
417         \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{true}, httpContext));
418     \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a17a213759b2cca8e91ca225b2e86739d_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=325pt]{classft_1_1_parser_a17a213759b2cca8e91ca225b2e86739d_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_a4eb83702cdd8772017f71dda995c4089}\label{classft_1_1_parser_a4eb83702cdd8772017f71dda995c4089}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!parse\+Location\+Context@{parse\+Location\+Context}}
\index{parse\+Location\+Context@{parse\+Location\+Context}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{parse\+Location\+Context()}{parseLocationContext()}}
{\footnotesize\ttfamily std\+::pair$<$ bool, \hyperlink{classft_1_1_location_block}{Location\+Block} $>$ parse\+Location\+Context (\begin{DoxyParamCaption}\item[{\hyperlink{classft_1_1_server_block}{Server\+Block} \&}]{server\+Context,  }\item[{std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$}]{valid\+Directive }\end{DoxyParamCaption})}



Definition at line 560 of file Parser.\+cpp.


\begin{DoxyCode}
561     \{
562         std::vector<Token>::iterator parseStart = \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_};
563         std::pair<bool, std::vector<Directive> > directives;
564         std::pair<bool, Token> possibleOperator;
565 
566         std::cout << \textcolor{stringliteral}{"We have a location block directive: "} << validDirective.second.name << \textcolor{stringliteral}{"\(\backslash\)n"};
567         std::vector<std::string>::iterator  currtToken = validDirective.second.parameters.begin();
568         std::vector<std::string>::iterator  endToken = validDirective.second.parameters.end();
569         \textcolor{keywordflow}{for} (; currtToken != endToken; ++currtToken)
570             std::cout << \textcolor{stringliteral}{"location parameter: "} << *currtToken << \textcolor{stringliteral}{"\(\backslash\)n"};
571         LocationBlock   locationContext(serverContext);
572         std::cout << \textcolor{stringliteral}{"location context created."} << \textcolor{stringliteral}{"\(\backslash\)n"};
573         \textcolor{comment}{//possibleOperator = expectOperator("\}");}
574         possibleOperator = \hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(\hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a6411d9d6073252e4d316493506bbb979}{OPERATOR}, \textcolor{stringliteral}{"\}"});
575         \textcolor{comment}{//while (expectOperator("\}").first == false)}
576         std::cout << \textcolor{stringliteral}{"before while possible operator in parse location context: "} << possibleOperator.first
       << \textcolor{stringliteral}{", "};
577         std::cout << possibleOperator.second.text << \textcolor{stringliteral}{"\(\backslash\)n"};
578         \textcolor{keywordflow}{while} (possibleOperator.first == \textcolor{keyword}{false})
579         \{
580             \textcolor{comment}{//std::cout << "possible operator in parse location context: " << possibleOperator.second.text
       << "\(\backslash\)n";}
581             directives = \hyperlink{classft_1_1_parser_aa8d68b83134b46e4b9115d9acd0cbf57}{parseContextBody}();
582             std::cout << \textcolor{stringliteral}{"directives first in parse location context: "} << directives.first << \textcolor{stringliteral}{"\(\backslash\)n"};
583             \textcolor{keywordflow}{if} (directives.first == \textcolor{keyword}{false})
584             \{
585                 std::cout << \textcolor{stringliteral}{"directives first false in parse location context: "} << \textcolor{stringliteral}{"\(\backslash\)n"};
586                 \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
587                 \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, locationContext));
588             \}
589             \textcolor{comment}{//locationContext.directiveList.insert(locationContext.directiveList.end(),
       directives.second.begin(), directives.second.end());}
590             std::cout << \textcolor{stringliteral}{"currnt token in parse location context: "} << 
      \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_}->text << \textcolor{stringliteral}{"\(\backslash\)n"};
591             \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a82bee2278db1afa69bbb6eb6f192743c}{setLocationDirectiveParameter}(locationContext, directives.
      second) == \textcolor{keyword}{false})
592                 \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, locationContext));
593             std::cout << \textcolor{stringliteral}{"currnt token af setLocation in parse location context: "} << 
      \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_}->text << \textcolor{stringliteral}{"\(\backslash\)n"};
594             possibleOperator = \hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(\hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a6411d9d6073252e4d316493506bbb979}{OPERATOR}, \textcolor{stringliteral}{"\}"});
595         \}
596 \textcolor{comment}{/*}
597 \textcolor{comment}{        if (expectOperator("\}").first == false)}
598 \textcolor{comment}{        \{}
599 \textcolor{comment}{            std::cout << "Error: Location context has not successfuly been enclosed with a closing curly
       braket.\(\backslash\)n";}
600 \textcolor{comment}{            return (std::make\_pair(false, locationContext));}
601 \textcolor{comment}{        \}}
602 \textcolor{comment}{*/}
603         std::cout << \textcolor{stringliteral}{"return true in parse location context: "} << \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_}->text << \textcolor{stringliteral}{"\(\backslash\)n"};
604         \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{true}, locationContext));
605     \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a4eb83702cdd8772017f71dda995c4089_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a4eb83702cdd8772017f71dda995c4089_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_ae53bb700e0344f7af2519a5af3ae4230}\label{classft_1_1_parser_ae53bb700e0344f7af2519a5af3ae4230}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!parse\+Server\+Context@{parse\+Server\+Context}}
\index{parse\+Server\+Context@{parse\+Server\+Context}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{parse\+Server\+Context()}{parseServerContext()}}
{\footnotesize\ttfamily std\+::pair$<$ bool, \hyperlink{classft_1_1_server_block}{Server\+Block} $>$ parse\+Server\+Context (\begin{DoxyParamCaption}\item[{\hyperlink{classft_1_1_http_block}{Http\+Block} \&}]{http\+Context,  }\item[{std\+::pair$<$ bool, \hyperlink{classft_1_1_directive}{Directive} $>$}]{valid\+Directive }\end{DoxyParamCaption})}



Definition at line 446 of file Parser.\+cpp.


\begin{DoxyCode}
447     \{
448         std::vector<Token>::iterator parseStart = \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_};
449         std::pair<bool, std::vector<Directive> > directives;
450         std::pair<bool, Token> possibleOperator = \hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(
      \hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a6411d9d6073252e4d316493506bbb979}{OPERATOR}, \textcolor{stringliteral}{"\}"});
451 
452         std::cout << \textcolor{stringliteral}{"We have a server block directive: "} << validDirective.second.name << \textcolor{stringliteral}{"\(\backslash\)n"};
453         ServerBlock serverContext(httpContext);
454         \textcolor{comment}{//while (expectOperator("\}").first == false)}
455         \textcolor{comment}{//while (expectToken(OPERATOR, "\}").first == false)}
456         \textcolor{keywordflow}{while} (possibleOperator.first == \textcolor{keyword}{false})
457         \{
458             validDirective = \hyperlink{classft_1_1_parser_a002b236022851df6ef2203aab9b24a73}{expectLocationContext}();
459             \textcolor{keywordflow}{if} (validDirective.first == \textcolor{keyword}{false} &&
460                  (validDirective.second.directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67c96b24b23bcb408bae7626730a04b7}{SERVER} || validDirective.second.directive == 
      \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da67e044074f46e6cea22788527da5f02e}{HTTP}))
461             \{
462                 \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
463                 \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, serverContext));
464             \}
465             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((validDirective.first == \textcolor{keyword}{false}) &&
466                      (validDirective.second.directive != \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da1e9e3944b93fde52c7c92e1e15dcaf4a}{LOCATION}))
467             \{
468                 std::cout << \textcolor{stringliteral}{"there is no location block, start to parse context body, "};
469                 std::cout << \textcolor{stringliteral}{"currentToken is :"} << \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_}->text << \textcolor{stringliteral}{"\(\backslash\)n"};
470                 directives = \hyperlink{classft_1_1_parser_aa8d68b83134b46e4b9115d9acd0cbf57}{parseContextBody}();
471                 \textcolor{keywordflow}{if} (directives.first == \textcolor{keyword}{false})
472                 \{
473                     std::cout << \textcolor{stringliteral}{"directives first false in parse server context: "} << \textcolor{stringliteral}{"\(\backslash\)n"};
474                     \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
475                     \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, serverContext));
476                 \}
477                 \textcolor{comment}{//serverContext.directiveList.insert(serverContext.directiveList.end(),
       directives.second.begin(), directives.second.end());}
478                 std::cout << \textcolor{stringliteral}{"currnt token in parse server context: "} << 
      \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_}->text << \textcolor{stringliteral}{"\(\backslash\)n"};
479                 \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a18c1b12280ce1a16246a8ba09156116f}{setServerDirectiveParameter}(serverContext, directives.second
      ) == \textcolor{keyword}{false})
480                     \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, serverContext));
481             \}
482             \textcolor{keywordflow}{else}
483             \{
484                 std::pair<bool, LocationBlock>  possibleLocationContext = 
      \hyperlink{classft_1_1_parser_a4eb83702cdd8772017f71dda995c4089}{parseLocationContext}(serverContext, validDirective);
485                         
486                 \textcolor{keywordflow}{if} (possibleLocationContext.first == \textcolor{keyword}{false})
487                 \{
488                     \hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} = parseStart;
489                     \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, serverContext));
490                 \}
491                 \textcolor{comment}{//std::cout << "possibleLocationContext :" <<
       possibleLocationContext.second.directiveList.begin()->name << "\(\backslash\)n";}
492                 serverContext.locationList.push\_back(possibleLocationContext.second);
493                 std::cout << \textcolor{stringliteral}{"One location context has been successfuly enclosed with a closing curly
       braket"} << \textcolor{stringliteral}{"\(\backslash\)n"};
494 \textcolor{comment}{/*}
495 \textcolor{comment}{                std::vector<Directive>::iterator    currtToken =
       possibleLocationContext.second.directiveList.begin();}
496 \textcolor{comment}{                std::vector<Directive>::iterator    endToken =
       possibleLocationContext.second.directiveList.end();}
497 \textcolor{comment}{                for (; currtToken != endToken; ++currtToken)}
498 \textcolor{comment}{                    std::cout << "locationContext Directive: " << (*currtToken).name << "\(\backslash\)n";}
499 \textcolor{comment}{*/}
500             \}
501             possibleOperator = \hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(\hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a6411d9d6073252e4d316493506bbb979}{OPERATOR}, \textcolor{stringliteral}{"\}"});
502         \}
503 
504         \textcolor{keywordflow}{if} (\hyperlink{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}{currentToken\_} == \hyperlink{classft_1_1_parser_a538ba3ab8ee1d0cef5cc3c999f3ab44c}{endToken\_} - 1 && \hyperlink{classft_1_1_parser_a1615a752d3642bb53598e2c8db810db0}{expectToken}(
      \hyperlink{namespaceft_aa520fbf142ba1e7e659590c07da31921a6411d9d6073252e4d316493506bbb979}{OPERATOR}, \textcolor{stringliteral}{"\}"}).first == \textcolor{keyword}{false})
505         \{
506             std::cout << \textcolor{stringliteral}{"Error: Server context has not successfuly been enclosed with a closing curly
       braket.\(\backslash\)n"};
507             \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{false}, serverContext));
508         \}
509 
510         \textcolor{comment}{//std::cout << "currnt token af while in parse server context: " << currentToken\_->text << "\(\backslash\)n";}
511         \textcolor{keywordflow}{return} (std::make\_pair(\textcolor{keyword}{true}, serverContext));
512     \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_ae53bb700e0344f7af2519a5af3ae4230_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_ae53bb700e0344f7af2519a5af3ae4230_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_a9f412d172694519d0d8dd9edacd257c0}\label{classft_1_1_parser_a9f412d172694519d0d8dd9edacd257c0}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!set\+Base\+Directive\+Parameter@{set\+Base\+Directive\+Parameter}}
\index{set\+Base\+Directive\+Parameter@{set\+Base\+Directive\+Parameter}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{set\+Base\+Directive\+Parameter()}{setBaseDirectiveParameter()}}
{\footnotesize\ttfamily bool set\+Base\+Directive\+Parameter (\begin{DoxyParamCaption}\item[{\hyperlink{classft_1_1_base_directives}{Base\+Directives} \&}]{context,  }\item[{std\+::vector$<$ \hyperlink{classft_1_1_directive}{Directive} $>$\+::iterator \&}]{current\+Directive }\end{DoxyParamCaption})}



Definition at line 226 of file Parser.\+cpp.


\begin{DoxyCode}
227     \{
228         std::cout << \textcolor{stringliteral}{"start setBase\(\backslash\)n"};
229         \textcolor{keywordflow}{if} (currentDirective->directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da026a7fa9f276b046081164564a62a6d6}{CLIENT\_MAX\_BODY\_SIZE})
230         \{
231             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}       value;
232             std::string     inputString = (*currentDirective->parameters.begin());
233             std::string::size\_type  n;
234 
235             \textcolor{keywordflow}{if} (inputString.length() != 0)
236             \{
237                 n = inputString.find\_first\_not\_of(\textcolor{stringliteral}{"0123456789"});
238                 \textcolor{keywordflow}{if} (n == std::string::npos)
239                 \{   
240                     value = std::strtoul((*currentDirective->parameters.begin()).c\_str(), NULL, 10); \textcolor{comment}{//
       string to unsigned long}
241                     context.setClientMaxBodySize(value); 
242                 \}
243                 \textcolor{keywordflow}{else}
244                 \{
245                     std::cout << \textcolor{stringliteral}{"Error: client\_max\_body\_size parameter should be an integer literal.\(\backslash\)n"};
246                     \textcolor{keywordflow}{return} (\textcolor{keyword}{false});
247                 \}
248 
249             \}
250         \}
251         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (currentDirective->directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75daaefe179bd74ff161beb62eb565186d89}{KEEPALIVE\_TIMEOUT})
252         \{
253             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}        value;
254             std::string     inputString = (*currentDirective->parameters.begin());
255             std::string::size\_type  n;
256 
257             \textcolor{keywordflow}{if} (inputString.length() != 0)
258             \{
259                 n = inputString.find\_first\_not\_of(\textcolor{stringliteral}{"0123456789"});
260                 \textcolor{keywordflow}{if} (n == std::string::npos)
261                 \{   
262                     std::istringstream(*currentDirective->parameters.begin()) >> value; \textcolor{comment}{// string to
       unsigned int}
263                     context.setKeepaliveTimeout(value); 
264                 \}
265                 \textcolor{keywordflow}{else}
266                 \{
267                     std::cout << \textcolor{stringliteral}{"Error: keepalive\_timeout parameter should be an integer literal.\(\backslash\)n"};
268                     \textcolor{keywordflow}{return} (\textcolor{keyword}{false});
269                 \}
270 
271             \}
272 
273         \}
274         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (currentDirective->directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da8ce880864e00bec4865ba027e32a466c}{AUTOINDEX})
275         \{
276             \textcolor{keywordflow}{if} ((*currentDirective->parameters.begin()) == \textcolor{stringliteral}{"on"})
277                 context.setAutoindex(\textcolor{keyword}{true});
278             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((*currentDirective->parameters.begin()) == \textcolor{stringliteral}{"off"})
279                 context.setAutoindex(\textcolor{keyword}{false});
280             \textcolor{keywordflow}{else}
281             \{
282                 std::cout << \textcolor{stringliteral}{"Error: autoindex parameter should be either 'on' or 'off'.\(\backslash\)n"};
283                 \textcolor{keywordflow}{return} (\textcolor{keyword}{false});
284             \}
285             \textcolor{comment}{//std::cout << "autoindex: " << httpContext.setautoindex\_ << std::endl;}
286         \}
287         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (currentDirective->directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75dad41208b99e347d1726824779b11ea11b}{ROOT})
288             context.setRoot((*currentDirective->parameters.begin()));
289         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (currentDirective->directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da69c9592b502329f43c77ad043a13e6d9}{ERROR\_PAGE})
290             \textcolor{comment}{//std::cout << *currentDirective->parameters.begin() << std::endl;}
291             context.setErrorPage(*(currentDirective->parameters.begin()));
292         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (currentDirective->directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da5f0c05bad71a7b0dd266aae7ce4b3579}{INDEX})
293         \{
294             std::vector<std::string>::iterator  currentParameter = currentDirective->parameters.begin();
295             std::vector<std::string>::iterator      endParameter = currentDirective->parameters.end();
296 
297             context.clearIndex();
298             \textcolor{keywordflow}{for} (; currentParameter != endParameter; ++currentParameter)
299                 context.setIndex(*currentParameter);
300         \}
301         \textcolor{keywordflow}{return} (\textcolor{keyword}{true});
302     \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a9f412d172694519d0d8dd9edacd257c0_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a9f412d172694519d0d8dd9edacd257c0_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_a5d287909e4c513e20b017ba0699b0cbf}\label{classft_1_1_parser_a5d287909e4c513e20b017ba0699b0cbf}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!set\+Http\+Directive\+Parameter@{set\+Http\+Directive\+Parameter}}
\index{set\+Http\+Directive\+Parameter@{set\+Http\+Directive\+Parameter}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{set\+Http\+Directive\+Parameter()}{setHttpDirectiveParameter()}}
{\footnotesize\ttfamily bool set\+Http\+Directive\+Parameter (\begin{DoxyParamCaption}\item[{\hyperlink{classft_1_1_http_block}{Http\+Block} \&}]{context,  }\item[{std\+::vector$<$ \hyperlink{classft_1_1_directive}{Directive} $>$}]{directive\+List }\end{DoxyParamCaption})}



Definition at line 306 of file Parser.\+cpp.


\begin{DoxyCode}
307     \{
308         std::vector<Directive>::iterator    currentDirective = directiveList.begin();
309         std::vector<Directive>::iterator    endDirective = directiveList.end();
310 
311         \textcolor{keywordflow}{for} (; currentDirective != endDirective; ++currentDirective)
312         \{
313             \hyperlink{classft_1_1_parser_a9f412d172694519d0d8dd9edacd257c0}{setBaseDirectiveParameter}(context, currentDirective);
314 \textcolor{comment}{/*}
315 \textcolor{comment}{            if (directive == SERVER)}
316 \textcolor{comment}{                setServerDirectiveParameter(context, currentDirective);}
317 \textcolor{comment}{            else if (directive == LOCATION)}
318 \textcolor{comment}{                setLocationDirectiveParameter(context, currentDirective);}
319 \textcolor{comment}{*/}
320         \}
321         \textcolor{keywordflow}{return} (\textcolor{keyword}{true});
322     \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a5d287909e4c513e20b017ba0699b0cbf_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a5d287909e4c513e20b017ba0699b0cbf_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_a82bee2278db1afa69bbb6eb6f192743c}\label{classft_1_1_parser_a82bee2278db1afa69bbb6eb6f192743c}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!set\+Location\+Directive\+Parameter@{set\+Location\+Directive\+Parameter}}
\index{set\+Location\+Directive\+Parameter@{set\+Location\+Directive\+Parameter}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{set\+Location\+Directive\+Parameter()}{setLocationDirectiveParameter()}}
{\footnotesize\ttfamily bool set\+Location\+Directive\+Parameter (\begin{DoxyParamCaption}\item[{\hyperlink{classft_1_1_location_block}{Location\+Block} \&}]{context,  }\item[{std\+::vector$<$ \hyperlink{classft_1_1_directive}{Directive} $>$}]{directive\+List }\end{DoxyParamCaption})}



Definition at line 199 of file Parser.\+cpp.


\begin{DoxyCode}
200     \{
201         std::vector<Directive>::iterator    currentDirective = directiveList.begin();
202         std::vector<Directive>::iterator    endDirective = directiveList.end();
203 
204         \textcolor{keywordflow}{for} (; currentDirective != endDirective; ++currentDirective)
205         \{
206             \hyperlink{classft_1_1_parser_a9f412d172694519d0d8dd9edacd257c0}{setBaseDirectiveParameter}(context, currentDirective);
207             \textcolor{keywordflow}{if} (currentDirective->directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da520e09ffec033636dba711f3441cc600}{RETURN})
208             \{
209                 std::vector<std::string>::iterator  currentParameter = currentDirective->parameters.begin()
      ;
210                 std::vector<std::string>::iterator      endParameter = currentDirective->parameters.end();
211                 \textcolor{keywordflow}{for} (; currentParameter != endParameter; ++currentParameter)
212                     context.setReturn(*currentParameter);
213                 \textcolor{comment}{// return error code error handling}
214             \}
215             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (currentDirective->directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da25b0e84438d71cc28e97f17a01cfde7a}{LIMIT\_EXCEPT})
216             \{
217                 std::vector<std::string>::iterator  currentParameter = currentDirective->parameters.begin()
      ;
218                 std::vector<std::string>::iterator      endParameter = currentDirective->parameters.end();
219                 \textcolor{keywordflow}{for} (; currentParameter != endParameter; ++currentParameter)
220                     context.setLimitExcept(*currentParameter);
221             \}
222         \}
223         \textcolor{keywordflow}{return} (\textcolor{keyword}{true});
224     \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a82bee2278db1afa69bbb6eb6f192743c_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a82bee2278db1afa69bbb6eb6f192743c_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classft_1_1_parser_a18c1b12280ce1a16246a8ba09156116f}\label{classft_1_1_parser_a18c1b12280ce1a16246a8ba09156116f}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!set\+Server\+Directive\+Parameter@{set\+Server\+Directive\+Parameter}}
\index{set\+Server\+Directive\+Parameter@{set\+Server\+Directive\+Parameter}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{set\+Server\+Directive\+Parameter()}{setServerDirectiveParameter()}}
{\footnotesize\ttfamily bool set\+Server\+Directive\+Parameter (\begin{DoxyParamCaption}\item[{\hyperlink{classft_1_1_server_block}{Server\+Block} \&}]{context,  }\item[{std\+::vector$<$ \hyperlink{classft_1_1_directive}{Directive} $>$}]{directive\+List }\end{DoxyParamCaption})}



Definition at line 164 of file Parser.\+cpp.


\begin{DoxyCode}
165     \{
166         std::vector<Directive>::iterator    currentDirective = directiveList.begin();
167         std::vector<Directive>::iterator    endDirective = directiveList.end();
168 
169         \textcolor{keywordflow}{for} (; currentDirective != endDirective; ++currentDirective)
170         \{
171             \hyperlink{classft_1_1_parser_a9f412d172694519d0d8dd9edacd257c0}{setBaseDirectiveParameter}(context, currentDirective);
172             \textcolor{keywordflow}{if} (currentDirective->directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da331ec9878c0ed22e62de969d4b96b5bb}{LISTEN})
173             \{
174                 context.setListen(*currentDirective->parameters.begin());
175             \}
176             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (currentDirective->directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da8e7adb687472b53e3ed632cbcb949d88}{SERVER\_NAME})
177             \{
178                 std::vector<std::string>::iterator  currentParameter = currentDirective->parameters.begin()
      ;
179                 std::vector<std::string>::iterator      endParameter = currentDirective->parameters.end();
180 
181                 context.clearServerName();
182                 \textcolor{keywordflow}{for} (; currentParameter != endParameter; ++currentParameter)
183                 \{
184                     context.setServerName(*currentParameter);
185                 \}
186             \}
187             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (currentDirective->directive == \hyperlink{namespaceft_a5a5554dff10f0dc50bae4cc5825ad75da520e09ffec033636dba711f3441cc600}{RETURN})
188             \{
189                 std::vector<std::string>::iterator  currentParameter = currentDirective->parameters.begin()
      ;
190                 std::vector<std::string>::iterator      endParameter = currentDirective->parameters.end();
191                 \textcolor{keywordflow}{for} (; currentParameter != endParameter; ++currentParameter)
192                     context.setReturn(*currentParameter);
193                 \textcolor{comment}{// return error code error handling}
194             \}
195         \}
196         \textcolor{keywordflow}{return} (\textcolor{keyword}{true});
197     \}
\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a18c1b12280ce1a16246a8ba09156116f_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classft_1_1_parser_a18c1b12280ce1a16246a8ba09156116f_icgraph}
\end{center}
\end{figure}


\subsection{Member Data Documentation}
\mbox{\Hypertarget{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}\label{classft_1_1_parser_a942c5b794d108f144c5b5028aaa34cb6}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!current\+Token\+\_\+@{current\+Token\+\_\+}}
\index{current\+Token\+\_\+@{current\+Token\+\_\+}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{current\+Token\+\_\+}{currentToken\_}}
{\footnotesize\ttfamily std\+::vector$<$\hyperlink{classft_1_1_token}{Token}$>$\+::iterator current\+Token\+\_\+\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 21 of file Parser.\+hpp.

\mbox{\Hypertarget{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}\label{classft_1_1_parser_abe21d1e60d970dd268181e79250b5399}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!directives\+\_\+@{directives\+\_\+}}
\index{directives\+\_\+@{directives\+\_\+}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{directives\+\_\+}{directives\_}}
{\footnotesize\ttfamily std\+::map$<$std\+::string, \hyperlink{classft_1_1_directive}{Directive}$>$ directives\+\_\+\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 23 of file Parser.\+hpp.

\mbox{\Hypertarget{classft_1_1_parser_a538ba3ab8ee1d0cef5cc3c999f3ab44c}\label{classft_1_1_parser_a538ba3ab8ee1d0cef5cc3c999f3ab44c}} 
\index{ft\+::\+Parser@{ft\+::\+Parser}!end\+Token\+\_\+@{end\+Token\+\_\+}}
\index{end\+Token\+\_\+@{end\+Token\+\_\+}!ft\+::\+Parser@{ft\+::\+Parser}}
\subsubsection{\texorpdfstring{end\+Token\+\_\+}{endToken\_}}
{\footnotesize\ttfamily std\+::vector$<$\hyperlink{classft_1_1_token}{Token}$>$\+::iterator end\+Token\+\_\+\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 22 of file Parser.\+hpp.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
\hyperlink{_parser_8hpp}{Parser.\+hpp}\item 
\hyperlink{dummy_8cpp}{dummy.\+cpp}\item 
\hyperlink{_parser_8cpp}{Parser.\+cpp}\end{DoxyCompactItemize}
